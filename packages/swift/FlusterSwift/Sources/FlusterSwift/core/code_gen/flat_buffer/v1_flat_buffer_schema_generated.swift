// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public struct SharedWebviewData_WebviewJavascriptError: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case message = 4
    case url = 6
    case line = 8
    case column = 10
    case error = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var message: String? { let o = _accessor.offset(VTOFFSET.message.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var messageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.message.v) }
  public var url: String? { let o = _accessor.offset(VTOFFSET.url.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var line: String? { let o = _accessor.offset(VTOFFSET.line.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var lineSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.line.v) }
  public var column: String? { let o = _accessor.offset(VTOFFSET.column.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var columnSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.column.v) }
  public var error: String? { let o = _accessor.offset(VTOFFSET.error.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var errorSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.error.v) }
  public static func startWebviewJavascriptError(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(message: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: message, at: VTOFFSET.message.p) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(line: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: line, at: VTOFFSET.line.p) }
  public static func add(column: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: column, at: VTOFFSET.column.p) }
  public static func add(error: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: error, at: VTOFFSET.error.p) }
  public static func endWebviewJavascriptError(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createWebviewJavascriptError(
    _ fbb: inout FlatBufferBuilder,
    messageOffset message: Offset = Offset(),
    urlOffset url: Offset = Offset(),
    lineOffset line: Offset = Offset(),
    columnOffset column: Offset = Offset(),
    errorOffset error: Offset = Offset()
  ) -> Offset {
    let __start = SharedWebviewData_WebviewJavascriptError.startWebviewJavascriptError(&fbb)
    SharedWebviewData_WebviewJavascriptError.add(message: message, &fbb)
    SharedWebviewData_WebviewJavascriptError.add(url: url, &fbb)
    SharedWebviewData_WebviewJavascriptError.add(line: line, &fbb)
    SharedWebviewData_WebviewJavascriptError.add(column: column, &fbb)
    SharedWebviewData_WebviewJavascriptError.add(error: error, &fbb)
    return SharedWebviewData_WebviewJavascriptError.endWebviewJavascriptError(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.message.p, fieldName: "message", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.line.p, fieldName: "line", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.column.p, fieldName: "column", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.error.p, fieldName: "error", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Dictionary_DictionaryEntryModel: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case label = 6
    case body = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String! { let o = _accessor.offset(VTOFFSET.id.v); return _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var label: String! { let o = _accessor.offset(VTOFFSET.label.v); return _accessor.string(at: o) }
  public var labelSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.label.v) }
  public var body: String! { let o = _accessor.offset(VTOFFSET.body.v); return _accessor.string(at: o) }
  public var bodySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.body.v) }
  public static func startDictionaryEntryModel(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(label: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: label, at: VTOFFSET.label.p) }
  public static func add(body: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: body, at: VTOFFSET.body.p) }
  public static func endDictionaryEntryModel(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8]); return end }
  public static func createDictionaryEntryModel(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset,
    labelOffset label: Offset,
    bodyOffset body: Offset
  ) -> Offset {
    let __start = Dictionary_DictionaryEntryModel.startDictionaryEntryModel(&fbb)
    Dictionary_DictionaryEntryModel.add(id: id, &fbb)
    Dictionary_DictionaryEntryModel.add(label: label, &fbb)
    Dictionary_DictionaryEntryModel.add(body: body, &fbb)
    return Dictionary_DictionaryEntryModel.endDictionaryEntryModel(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.label.p, fieldName: "label", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.body.p, fieldName: "body", required: true, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Dictionary_DictionaryData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case entries = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasEntries: Bool { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? false : true }
  public var entriesCount: Int32 { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func entries(at index: Int32) -> Dictionary_DictionaryEntryModel? { let o = _accessor.offset(VTOFFSET.entries.v); return o == 0 ? nil : Dictionary_DictionaryEntryModel(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startDictionaryData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(entries: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: entries, at: VTOFFSET.entries.p) }
  public static func endDictionaryData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createDictionaryData(
    _ fbb: inout FlatBufferBuilder,
    entriesVectorOffset entries: Offset
  ) -> Offset {
    let __start = Dictionary_DictionaryData.startDictionaryData(&fbb)
    Dictionary_DictionaryData.addVectorOf(entries: entries, &fbb)
    return Dictionary_DictionaryData.endDictionaryData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.entries.p, fieldName: "entries", required: true, type: ForwardOffset<Vector<ForwardOffset<Dictionary_DictionaryEntryModel>, Dictionary_DictionaryEntryModel>>.self)
    _v.finish()
  }
}

public struct MdxSerialization_CitationResultBuffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case citationKey = 4
    case idx = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var citationKey: String! { let o = _accessor.offset(VTOFFSET.citationKey.v); return _accessor.string(at: o) }
  public var citationKeySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.citationKey.v) }
  public var idx: UInt8 { let o = _accessor.offset(VTOFFSET.idx.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startCitationResultBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(citationKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: citationKey, at: VTOFFSET.citationKey.p) }
  public static func add(idx: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: idx, def: 0, at: VTOFFSET.idx.p) }
  public static func endCitationResultBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createCitationResultBuffer(
    _ fbb: inout FlatBufferBuilder,
    citationKeyOffset citationKey: Offset,
    idx: UInt8 = 0
  ) -> Offset {
    let __start = MdxSerialization_CitationResultBuffer.startCitationResultBuffer(&fbb)
    MdxSerialization_CitationResultBuffer.add(citationKey: citationKey, &fbb)
    MdxSerialization_CitationResultBuffer.add(idx: idx, &fbb)
    return MdxSerialization_CitationResultBuffer.endCitationResultBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.citationKey.p, fieldName: "citationKey", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.idx.p, fieldName: "idx", required: false, type: UInt8.self)
    _v.finish()
  }
}

public struct MdxSerialization_TagResultBuffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case body = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var body: String! { let o = _accessor.offset(VTOFFSET.body.v); return _accessor.string(at: o) }
  public var bodySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.body.v) }
  public static func startTagResultBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(body: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: body, at: VTOFFSET.body.p) }
  public static func endTagResultBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createTagResultBuffer(
    _ fbb: inout FlatBufferBuilder,
    bodyOffset body: Offset
  ) -> Offset {
    let __start = MdxSerialization_TagResultBuffer.startTagResultBuffer(&fbb)
    MdxSerialization_TagResultBuffer.add(body: body, &fbb)
    return MdxSerialization_TagResultBuffer.endTagResultBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.body.p, fieldName: "body", required: true, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct MdxSerialization_DictionaryEntryResultBuffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case label = 4
    case body = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var label: String! { let o = _accessor.offset(VTOFFSET.label.v); return _accessor.string(at: o) }
  public var labelSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.label.v) }
  public var body: String! { let o = _accessor.offset(VTOFFSET.body.v); return _accessor.string(at: o) }
  public var bodySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.body.v) }
  public static func startDictionaryEntryResultBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(label: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: label, at: VTOFFSET.label.p) }
  public static func add(body: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: body, at: VTOFFSET.body.p) }
  public static func endDictionaryEntryResultBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createDictionaryEntryResultBuffer(
    _ fbb: inout FlatBufferBuilder,
    labelOffset label: Offset,
    bodyOffset body: Offset
  ) -> Offset {
    let __start = MdxSerialization_DictionaryEntryResultBuffer.startDictionaryEntryResultBuffer(&fbb)
    MdxSerialization_DictionaryEntryResultBuffer.add(label: label, &fbb)
    MdxSerialization_DictionaryEntryResultBuffer.add(body: body, &fbb)
    return MdxSerialization_DictionaryEntryResultBuffer.endDictionaryEntryResultBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.label.p, fieldName: "label", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.body.p, fieldName: "body", required: true, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct MdxSerialization_FrontMatterResultBuffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ignoreParsers = 4
    case title = 6
    case userDefinedId = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasIgnoreParsers: Bool { let o = _accessor.offset(VTOFFSET.ignoreParsers.v); return o == 0 ? false : true }
  public var ignoreParsersCount: Int32 { let o = _accessor.offset(VTOFFSET.ignoreParsers.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ignoreParsers(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ignoreParsers.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var title: String? { let o = _accessor.offset(VTOFFSET.title.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var titleSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.title.v) }
  public var userDefinedId: String? { let o = _accessor.offset(VTOFFSET.userDefinedId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var userDefinedIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.userDefinedId.v) }
  public static func startFrontMatterResultBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(ignoreParsers: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ignoreParsers, at: VTOFFSET.ignoreParsers.p) }
  public static func add(title: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: title, at: VTOFFSET.title.p) }
  public static func add(userDefinedId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: userDefinedId, at: VTOFFSET.userDefinedId.p) }
  public static func endFrontMatterResultBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createFrontMatterResultBuffer(
    _ fbb: inout FlatBufferBuilder,
    ignoreParsersVectorOffset ignoreParsers: Offset,
    titleOffset title: Offset = Offset(),
    userDefinedIdOffset userDefinedId: Offset = Offset()
  ) -> Offset {
    let __start = MdxSerialization_FrontMatterResultBuffer.startFrontMatterResultBuffer(&fbb)
    MdxSerialization_FrontMatterResultBuffer.addVectorOf(ignoreParsers: ignoreParsers, &fbb)
    MdxSerialization_FrontMatterResultBuffer.add(title: title, &fbb)
    MdxSerialization_FrontMatterResultBuffer.add(userDefinedId: userDefinedId, &fbb)
    return MdxSerialization_FrontMatterResultBuffer.endFrontMatterResultBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ignoreParsers.p, fieldName: "ignoreParsers", required: true, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.title.p, fieldName: "title", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.userDefinedId.p, fieldName: "userDefinedId", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct MdxSerialization_MdxParsingResultBuffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case parsedContent = 4
    case tags = 6
    case frontMatter = 8
    case citations = 10
    case dictionaryEntries = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var parsedContent: String! { let o = _accessor.offset(VTOFFSET.parsedContent.v); return _accessor.string(at: o) }
  public var parsedContentSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.parsedContent.v) }
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> MdxSerialization_TagResultBuffer? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : MdxSerialization_TagResultBuffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var frontMatter: MdxSerialization_FrontMatterResultBuffer? { let o = _accessor.offset(VTOFFSET.frontMatter.v); return o == 0 ? nil : MdxSerialization_FrontMatterResultBuffer(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var hasCitations: Bool { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? false : true }
  public var citationsCount: Int32 { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func citations(at index: Int32) -> MdxSerialization_CitationResultBuffer? { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? nil : MdxSerialization_CitationResultBuffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasDictionaryEntries: Bool { let o = _accessor.offset(VTOFFSET.dictionaryEntries.v); return o == 0 ? false : true }
  public var dictionaryEntriesCount: Int32 { let o = _accessor.offset(VTOFFSET.dictionaryEntries.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dictionaryEntries(at index: Int32) -> MdxSerialization_DictionaryEntryResultBuffer? { let o = _accessor.offset(VTOFFSET.dictionaryEntries.v); return o == 0 ? nil : MdxSerialization_DictionaryEntryResultBuffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startMdxParsingResultBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(parsedContent: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: parsedContent, at: VTOFFSET.parsedContent.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func add(frontMatter: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: frontMatter, at: VTOFFSET.frontMatter.p) }
  public static func addVectorOf(citations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: citations, at: VTOFFSET.citations.p) }
  public static func addVectorOf(dictionaryEntries: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dictionaryEntries, at: VTOFFSET.dictionaryEntries.p) }
  public static func endMdxParsingResultBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createMdxParsingResultBuffer(
    _ fbb: inout FlatBufferBuilder,
    parsedContentOffset parsedContent: Offset,
    tagsVectorOffset tags: Offset,
    frontMatterOffset frontMatter: Offset = Offset(),
    citationsVectorOffset citations: Offset = Offset(),
    dictionaryEntriesVectorOffset dictionaryEntries: Offset = Offset()
  ) -> Offset {
    let __start = MdxSerialization_MdxParsingResultBuffer.startMdxParsingResultBuffer(&fbb)
    MdxSerialization_MdxParsingResultBuffer.add(parsedContent: parsedContent, &fbb)
    MdxSerialization_MdxParsingResultBuffer.addVectorOf(tags: tags, &fbb)
    MdxSerialization_MdxParsingResultBuffer.add(frontMatter: frontMatter, &fbb)
    MdxSerialization_MdxParsingResultBuffer.addVectorOf(citations: citations, &fbb)
    MdxSerialization_MdxParsingResultBuffer.addVectorOf(dictionaryEntries: dictionaryEntries, &fbb)
    return MdxSerialization_MdxParsingResultBuffer.endMdxParsingResultBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.parsedContent.p, fieldName: "parsedContent", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: true, type: ForwardOffset<Vector<ForwardOffset<MdxSerialization_TagResultBuffer>, MdxSerialization_TagResultBuffer>>.self)
    try _v.visit(field: VTOFFSET.frontMatter.p, fieldName: "frontMatter", required: false, type: ForwardOffset<MdxSerialization_FrontMatterResultBuffer>.self)
    try _v.visit(field: VTOFFSET.citations.p, fieldName: "citations", required: false, type: ForwardOffset<Vector<ForwardOffset<MdxSerialization_CitationResultBuffer>, MdxSerialization_CitationResultBuffer>>.self)
    try _v.visit(field: VTOFFSET.dictionaryEntries.p, fieldName: "dictionaryEntries", required: false, type: ForwardOffset<Vector<ForwardOffset<MdxSerialization_DictionaryEntryResultBuffer>, MdxSerialization_DictionaryEntryResultBuffer>>.self)
    _v.finish()
  }
}

public struct MdxSerialization_Request_ParseMdxOptions: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case content = 4
    case citations = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var content: String? { let o = _accessor.offset(VTOFFSET.content.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var contentSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.content.v) }
  public var hasCitations: Bool { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? false : true }
  public var citationsCount: Int32 { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func citations(at index: Int32) -> MdxSerialization_CitationResultBuffer? { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? nil : MdxSerialization_CitationResultBuffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startParseMdxOptions(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(content: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: content, at: VTOFFSET.content.p) }
  public static func addVectorOf(citations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: citations, at: VTOFFSET.citations.p) }
  public static func endParseMdxOptions(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParseMdxOptions(
    _ fbb: inout FlatBufferBuilder,
    contentOffset content: Offset = Offset(),
    citationsVectorOffset citations: Offset = Offset()
  ) -> Offset {
    let __start = MdxSerialization_Request_ParseMdxOptions.startParseMdxOptions(&fbb)
    MdxSerialization_Request_ParseMdxOptions.add(content: content, &fbb)
    MdxSerialization_Request_ParseMdxOptions.addVectorOf(citations: citations, &fbb)
    return MdxSerialization_Request_ParseMdxOptions.endParseMdxOptions(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.content.p, fieldName: "content", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.citations.p, fieldName: "citations", required: false, type: ForwardOffset<Vector<ForwardOffset<MdxSerialization_CitationResultBuffer>, MdxSerialization_CitationResultBuffer>>.self)
    _v.finish()
  }
}

public struct MdxSerialization_NoteDetails_NoteDetailDataBuffer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case noteId = 4
    case title = 6
    case summary = 8
    case topic = 10
    case subject = 12
    case tags = 14
    case citations = 16
    case lastModifiedString = 18
    case lastReadString = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var noteId: String! { let o = _accessor.offset(VTOFFSET.noteId.v); return _accessor.string(at: o) }
  public var noteIdSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.noteId.v) }
  public var title: String! { let o = _accessor.offset(VTOFFSET.title.v); return _accessor.string(at: o) }
  public var titleSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.title.v) }
  public var summary: String? { let o = _accessor.offset(VTOFFSET.summary.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var summarySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.summary.v) }
  public var topic: String? { let o = _accessor.offset(VTOFFSET.topic.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var topicSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.topic.v) }
  public var subject: String? { let o = _accessor.offset(VTOFFSET.subject.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var subjectSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.subject.v) }
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? false : true }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> MdxSerialization_TagResultBuffer? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : MdxSerialization_TagResultBuffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasCitations: Bool { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? false : true }
  public var citationsCount: Int32 { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func citations(at index: Int32) -> MdxSerialization_CitationResultBuffer? { let o = _accessor.offset(VTOFFSET.citations.v); return o == 0 ? nil : MdxSerialization_CitationResultBuffer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var lastModifiedString: String! { let o = _accessor.offset(VTOFFSET.lastModifiedString.v); return _accessor.string(at: o) }
  public var lastModifiedStringSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.lastModifiedString.v) }
  public var lastReadString: String! { let o = _accessor.offset(VTOFFSET.lastReadString.v); return _accessor.string(at: o) }
  public var lastReadStringSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.lastReadString.v) }
  public static func startNoteDetailDataBuffer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(noteId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: noteId, at: VTOFFSET.noteId.p) }
  public static func add(title: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: title, at: VTOFFSET.title.p) }
  public static func add(summary: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: summary, at: VTOFFSET.summary.p) }
  public static func add(topic: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: topic, at: VTOFFSET.topic.p) }
  public static func add(subject: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: subject, at: VTOFFSET.subject.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func addVectorOf(citations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: citations, at: VTOFFSET.citations.p) }
  public static func add(lastModifiedString: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lastModifiedString, at: VTOFFSET.lastModifiedString.p) }
  public static func add(lastReadString: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: lastReadString, at: VTOFFSET.lastReadString.p) }
  public static func endNoteDetailDataBuffer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 14, 16, 18, 20]); return end }
  public static func createNoteDetailDataBuffer(
    _ fbb: inout FlatBufferBuilder,
    noteIdOffset noteId: Offset,
    titleOffset title: Offset,
    summaryOffset summary: Offset = Offset(),
    topicOffset topic: Offset = Offset(),
    subjectOffset subject: Offset = Offset(),
    tagsVectorOffset tags: Offset,
    citationsVectorOffset citations: Offset,
    lastModifiedStringOffset lastModifiedString: Offset,
    lastReadStringOffset lastReadString: Offset
  ) -> Offset {
    let __start = MdxSerialization_NoteDetails_NoteDetailDataBuffer.startNoteDetailDataBuffer(&fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(noteId: noteId, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(title: title, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(summary: summary, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(topic: topic, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(subject: subject, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.addVectorOf(tags: tags, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.addVectorOf(citations: citations, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(lastModifiedString: lastModifiedString, &fbb)
    MdxSerialization_NoteDetails_NoteDetailDataBuffer.add(lastReadString: lastReadString, &fbb)
    return MdxSerialization_NoteDetails_NoteDetailDataBuffer.endNoteDetailDataBuffer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.noteId.p, fieldName: "noteId", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.title.p, fieldName: "title", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.summary.p, fieldName: "summary", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.topic.p, fieldName: "topic", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.subject.p, fieldName: "subject", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: true, type: ForwardOffset<Vector<ForwardOffset<MdxSerialization_TagResultBuffer>, MdxSerialization_TagResultBuffer>>.self)
    try _v.visit(field: VTOFFSET.citations.p, fieldName: "citations", required: true, type: ForwardOffset<Vector<ForwardOffset<MdxSerialization_CitationResultBuffer>, MdxSerialization_CitationResultBuffer>>.self)
    try _v.visit(field: VTOFFSET.lastModifiedString.p, fieldName: "lastModifiedString", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.lastReadString.p, fieldName: "lastReadString", required: true, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

