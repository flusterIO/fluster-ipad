use crate::tauri::core::models::taggable::shared_taggable_model::SharedTaggableModel;
use gray_matter::Pod;
use serde::{Deserialize, Serialize};
use specta::Type;

/// This is the model as it exists in the database. All related external tables can be combined to form a
/// `FrontMatterModel` struct, which more closely represents the front matter as it appears in a
/// user's notes.
#[derive(Debug, Default, Clone, Serialize, Type, Deserialize)]
pub struct FrontMatterBaseModel {
    pub id: String,
    pub mdx_note_file_path: String,
    /// The user_provided_id is the id field as it appears in the user's note.  The id field in
    /// this struct is generated by Surreal.
    pub user_provided_id: Option<String>,
    pub title: String,
    pub summary: Option<String>,
    pub list_id: Option<String>,
    pub list_index: Option<i64>,
    // Tags must be part of a joining table as they are are many-to-many relationship. Setting the
    // topic and subject value here will work as it's a 1-many relationship.
    pub subject: Option<String>,
    pub topic: Option<String>,
}

// type BtreeValueArray = Vec<BTreeMap<&'static str, Value>>;

/// This model mirrors the structure of the front matter as it appears in a user's note, where the
/// nested entities represent the data as it is stored in the database. This model should handle
/// all parsing and saving of all nested models.
#[derive(Debug, Default, Clone, Serialize, Type, Deserialize)]
pub struct FrontMatterModel {
    pub id: String,
    pub mdx_note_file_path: String,
    /// The user_provided_id is the id field as it appears in the user's note.  The id field in
    /// this struct is generated by Surreal.
    pub user_provided_id: Option<String>,
    pub title: String,
    pub summary: Option<String>,
    pub list_id: Option<String>,
    pub list_index: Option<i64>,
    // Additional fields not in base model.
    pub tags: Vec<SharedTaggableModel>,
    pub subject: Option<SharedTaggableModel>,
    pub topic: Option<SharedTaggableModel>,
}

impl FrontMatterModel {
    pub fn from_gray_matter(pod: Option<Pod>, file_path: &str) -> FrontMatterModel {
        let mut tags: Vec<SharedTaggableModel> = Vec::new();
        match pod {
            None => FrontMatterModel {
                mdx_note_file_path: file_path.to_string(),
                ..Default::default()
            },
            Some(p) => {
                let mut x = FrontMatterModel {
                    mdx_note_file_path: file_path.to_string(),
                    ..Default::default()
                };
                // Set title
                let data = p.as_hashmap();
                if data.is_err() {
                    FrontMatterModel {
                        mdx_note_file_path: file_path.to_string(),
                        ..Default::default()
                    }
                } else {
                    let d = data.unwrap();
                    if d.contains_key("title") {
                        let title = d["title"].as_string();
                        if title.is_ok() {
                            x.title = title.unwrap();
                        }
                    }
                    // Set summary
                    if d.contains_key("summary") {
                        let summary = d["summary"].as_string();
                        if summary.is_ok() {
                            x.summary = Some(summary.unwrap());
                        }
                    }
                    // Set tags
                    if d.contains_key("tags") {
                        let mut item_tags = d["tags"].clone();
                        for _ in 0..item_tags.len() {
                            let tag_item = item_tags.pop().as_string();
                            if let Ok(item) = tag_item {
                                tags.push(SharedTaggableModel::new(item, None));
                            }
                        }
                    }
                    // Set subject
                    if d.contains_key("subject") {
                        let item_subject = d["subject"].clone();
                        x.subject = Some(SharedTaggableModel::new(
                            item_subject.as_string().unwrap(),
                            None,
                        ))
                    }
                    // Set topic
                    if d.contains_key("topic") {
                        let item_topic = d["topic"].clone();
                        x.topic = Some(SharedTaggableModel::new(
                            item_topic.as_string().unwrap(),
                            None,
                        ));
                    }
                    // Set note_id
                    if d.contains_key("id") {
                        let note_id = d["id"].as_string();
                        if note_id.is_ok() {
                            x.user_provided_id = Some(note_id.unwrap());
                        }
                    }

                    if d.contains_key("listId") {
                        let list_id = d["listId"].as_string();
                        if list_id.is_ok() {
                            x.list_id = Some(list_id.unwrap());
                        }
                    }
                    if d.contains_key("listIndex") {
                        let list_index = d["listIndex"].as_i64();
                        if list_index.is_ok() {
                            x.list_index = Some(list_index.unwrap());
                        }
                    }
                    x
                }
            }
        }
    }
}
