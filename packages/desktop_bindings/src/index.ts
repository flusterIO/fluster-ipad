// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
    async getOperatingSystem(): Promise<
        Result<SupportedOperatingSystem, FlusterError>
    > {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_operating_system") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async pathExists(filePath: string): Promise<boolean> {
        return await TAURI_INVOKE("path_exists", { filePath });
    },
    /**
     * Appends the path to the base_path if it is not already contained within the fs_path.
     * If the base_path is empty, it will always return the fs_path.
     */
    async normalizePath(fsPath: string, basePath: string): Promise<string> {
        return await TAURI_INVOKE("normalize_path", { fsPath, basePath });
    },
    async hideSplashScreen(): Promise<Result<null, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("hide_splash_screen") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async loadBinaryFile(
        rootRelativePath: string,
        basePath: string,
    ): Promise<Result<number[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("load_binary_file", {
                    rootRelativePath,
                    basePath,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async loadTabularFile(
        relativePath: string,
        basePath: string,
        withHasHeader: boolean,
    ): Promise<Result<Partial<{ [key in string]: JsonValue }>[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("load_tabular_file", {
                    relativePath,
                    basePath,
                    withHasHeader,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getDatabasePath(): Promise<Result<string, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_database_path") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getParsableFiles(
        opts: GetParsableFilesOptions,
    ): Promise<Result<ParsableFiles, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_parsable_files", { opts }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getEnvVar(envVar: string): Promise<string | null> {
        return await TAURI_INVOKE("get_env_var", { envVar });
    },
    async backupDatabaseObjects(
        outputDir: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("backup_database_objects", { outputDir }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createAutoSetting(
        data: AutoSettingModel[],
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_auto_setting", { data }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllAutoSettings(
        pagination: PaginationProps,
    ): Promise<Result<AutoSettingModel[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_all_auto_settings", { pagination }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteAutoSettingById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_auto_setting_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getDashboardData(): Promise<Result<DashboardData, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_dashboard_data") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getQrCodeSvg(content: string): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_qr_code_svg", { content }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getEnvironmentVariable(
        key: string,
    ): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_environment_variable", { key }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTextSimilarity(a: string, b: string): Promise<number> {
        return await TAURI_INVOKE("get_text_similarity", { a, b });
    },
    async getUniqueId(): Promise<string> {
        return await TAURI_INVOKE("get_unique_id");
    },
    async getTagSearchResults(
        tagValues: string[],
    ): Promise<Result<TraditionalSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_tag_search_results", { tagValues }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTopicSearchResults(
        tagValues: string[],
    ): Promise<Result<TraditionalSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_topic_search_results", { tagValues }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getSubjectSearchResults(
        tagValues: string[],
    ): Promise<Result<TraditionalSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_subject_search_results", { tagValues }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async semanticSearch(
        query: string,
        ai: AiSyncSettings,
    ): Promise<Result<SemanticSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("semantic_search", { query, ai }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllTags(): Promise<Result<SharedTaggableModel[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_all_tags") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllSubjects(): Promise<Result<SharedTaggableModel[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_all_subjects") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllTopics(): Promise<Result<SharedTaggableModel[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_all_topics") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getNotesByBibEntryId(
        bibEntryId: string,
    ): Promise<Result<TraditionalSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_notes_by_bib_entry_id", { bibEntryId }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Accepts the user defined equation_id field, not the auto-generated id.
     */
    async getNotesByEquationId(
        equationId: string,
    ): Promise<Result<TraditionalSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_notes_by_equation_id", { equationId }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getNoteByDictEntryLabel(
        dictEntryLabel: string,
    ): Promise<Result<TraditionalSearchResults, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_note_by_dict_entry_label", {
                    dictEntryLabel,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getExistingTaggables(): Promise<AllTaggableData> {
        return await TAURI_INVOKE("get_existing_taggables");
    },
    /**
     * For now this just returns all notes, unsorted since the dates can't be parsed on the rust side
     * for some inexplicable reason.
     */
    async getRecentlyAccessedNotes(): Promise<
        Result<MdxNoteGroup[], FlusterError>
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_recently_accessed_notes"),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * This wraps a series of functions handled by the fluster_native_interface package, conditionally
     * based on user settings and app state.
     */
    async syncLocalDatabase(
        opts: SyncFilesystemDirectoryOptions,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("sync_local_database", { opts }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveUtf8File(
        fsPath: string,
        fileContent: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_utf8_file", { fsPath, fileContent }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async readUtf8File(fsPath: string): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("read_utf8_file", { fsPath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async readFileToBytes(
        fsPath: string,
    ): Promise<Result<number[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("read_file_to_bytes", { fsPath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async writeFile(
        filePath: string,
        content: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("write_file", { filePath, content }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Make sure to enforce the root directory as a base for globs on the front end, otherwise the
     * entire computer will be searched.
     */
    async fsGlob(globString: string, basePath: string): Promise<string[]> {
        return await TAURI_INVOKE("fs_glob", { globString, basePath });
    },
    /**
     * This a file extension, without a leading '.'. For regular globs use fs_glob.
     * The n_threads field is a stringified integer representing the number of threads.
     */
    async fsFileExtensionGlob(
        fileExtension: string,
        basePath: string,
        nThreads: string,
    ): Promise<Result<string[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("fs_file_extension_glob", {
                    fileExtension,
                    basePath,
                    nThreads,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getFilesByFileExtensions(
        fileExtensions: string[],
        basePath: string,
        nThreads: string,
    ): Promise<Result<string[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_files_by_file_extensions", {
                    fileExtensions,
                    basePath,
                    nThreads,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async initializeDatabase(): Promise<Result<null, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("initialize_database") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async initializeDesktop(): Promise<Result<null, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("initialize_desktop") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async wipeDatabase(): Promise<Result<null, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("wipe_database") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getEmbeddedDoc(id: InternalEmbeddedDocsId): Promise<string> {
        return await TAURI_INVOKE("get_embedded_doc", { id });
    },
    async getDesktopHealthReport(): Promise<DesktopHealthReport> {
        return await TAURI_INVOKE("get_desktop_health_report");
    },
    async getEmbeddedDocByRelativePath(
        fp: string,
    ): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_embedded_doc_by_relative_path", { fp }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllEmbeddedDocs(): Promise<
        Result<EmbbeddedDocFile[], FlusterError>
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_all_embedded_docs"),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async addBookmark(noteFilePath: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("add_bookmark", { noteFilePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async removeBookmark(
        noteFilePath: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("remove_bookmark", { noteFilePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getBookmarkedNotes(): Promise<Result<MdxBookmarkData[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_bookmarked_notes") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async filePathIsBookmarked(
        noteFilePath: string,
    ): Promise<Result<boolean, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("file_path_is_bookmarked", { noteFilePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getDictionaryEntries(): Promise<
        Result<DictionaryEntryModel[], FlusterError>
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_dictionary_entries"),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * This method is used when the search param fsPath is set. This is similar to the way the app
     * worked in the previous rendtion when 'prefer fs' was enabled by the user.
     */
    async readMdxFromFs(
        fsPath: string,
    ): Promise<Result<MdxNoteGroup, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("read_mdx_from_fs", { fsPath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async readMdxFile(
        filePath: string,
    ): Promise<Result<MdxNoteGroup, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("read_mdx_file", { filePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async parseMdxString(
        mdxContent: string,
        filePath: string | null,
    ): Promise<Result<MdxNoteGroup, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("parse_mdx_string", { mdxContent, filePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async setLastReadByFilePath(
        filePath: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("set_last_read_by_file_path", { filePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async removeFrontMatter(mdxContent: string): Promise<string> {
        return await TAURI_INVOKE("remove_front_matter", { mdxContent });
    },
    async getNoteSummaries(
        pagination: PaginationProps,
    ): Promise<Result<NoteSummary[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_note_summaries", { pagination }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTocFromMarkdown(
        markdownContent: string,
    ): Promise<Result<TocEntry[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_toc_from_markdown", { markdownContent }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTocFromFsPath(
        fsPath: string,
    ): Promise<Result<TocEntry[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_toc_from_fs_path", { fsPath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async mdxNoteFullTextSearch(
        query: string,
        pagination: PaginationProps,
    ): Promise<Result<MdxNoteGroup[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("mdx_note_full_text_search", {
                    query,
                    pagination,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getNoteCount(
        predicate: string | null,
    ): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_note_count", { predicate }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getNoteGroupByFilePath(
        filePath: string,
    ): Promise<Result<MdxNoteGroup, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_note_group_by_file_path", { filePath }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getNoteByUserProvidedId(
        userProvidedId: string,
    ): Promise<Result<MdxNoteGroup, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_note_by_user_provided_id", {
                    userProvidedId,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteSettingState(
        settingsId: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_setting_state", { settingsId }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveSettingState(
        jsonString: string,
        settingsId: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_setting_state", {
                    jsonString,
                    settingsId,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getSettingState(): Promise<Result<string, FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_setting_state") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Returns the string which points the location of mathjax that needs to be passed to the front
     * end. This is the location that mathjax is copied *to*, not from.
     */
    async getMathjaxPath(): Promise<MathjaxData> {
        return await TAURI_INVOKE("get_mathjax_path");
    },
    async getEquations(): Promise<Result<EquationData[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_equations") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveEquation(item: EquationData): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_equation", { item }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getEquationById(
        id: string,
    ): Promise<Result<EquationData, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_equation_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteEquationById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_equation_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getEquationByUserProvidedId(
        id: string[],
    ): Promise<Result<EquationModel[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_equation_by_user_provided_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async grid2d(
        x: AxisGeneratorProps,
        y: AxisGeneratorProps,
    ): Promise<number[][][]> {
        return await TAURI_INVOKE("grid_2d", { x, y });
    },
    async logspace(
        base: number,
        a: number,
        b: number,
        n: string,
    ): Promise<number[]> {
        return await TAURI_INVOKE("logspace", { base, a, b, n });
    },
    async arange(from: number, to: number, step: number): Promise<number[]> {
        return await TAURI_INVOKE("arange", { from, to, step });
    },
    async linspace(from: number, to: number, nItems: string): Promise<number[]> {
        return await TAURI_INVOKE("linspace", { from, to, nItems });
    },
    async axisGrid(axis: AxisGeneratorProps): Promise<number[][]> {
        return await TAURI_INVOKE("axis_grid", { axis });
    },
    /**
     * Note that the values are all in array's and that tags is a 2d array. This is so that for each
     * index in the snippets array, there is an array at that index in the tags array with the tags
     * the snippet at that index contains.
     * While it's weird to think about a database's data in this way, this very similar to how pandas and
     * polars handle their data.
     */
    async saveSnippet(item: SnippetData): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_snippet", { item }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getSnippets(
        opts: GetSnippetsParams,
    ): Promise<Result<SnippetData[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_snippets", { opts }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteSnippetById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_snippet_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getSnippetById(
        id: string,
    ): Promise<Result<[SnippetModel, SharedTaggableModel[]], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_snippet_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getBibEntries(
        predicate: string | null,
        pagination: PaginationProps,
    ): Promise<Result<BibEntryModel[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_bib_entries", { predicate, pagination }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getBibEntryCount(
        predicate: string | null,
    ): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_bib_entry_count", { predicate }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async syncBib(entries: BibEntryModel[]): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("sync_bib", { entries }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveBibEntries(
        entries: BibEntryModel[],
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_bib_entries", { entries }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getBibEntryById(
        id: string,
    ): Promise<Result<BibEntryModel, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_bib_entry_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async bibEntriesFullTextSearch(
        query: string,
        pagination: PaginationProps,
    ): Promise<Result<BibEntryModel[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("bib_entries_full_text_search", {
                    query,
                    pagination,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAiChatById(
        chatId: string,
    ): Promise<Result<AiChatData, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_ai_chat_by_id", { chatId }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createNewAiChat(
        label: string,
        model: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_new_ai_chat", { label, model }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllAiChats(): Promise<Result<AiChatModel[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_all_ai_chats") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteChatById(chatId: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_chat_by_id", { chatId }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Until dates can be parsed on the rust side, the history must be passed in already sorted by
     * date.
     */
    async addAiChatRequest(
        chatId: string,
        ai: AiSyncSettings,
        chatInput: AiChatMessageModel,
        chatHistory: AiChatMessageModel[],
        streamChannel: TAURI_CHANNEL<AiChatMessageUpdateEventProps>,
    ): Promise<Result<AiChatMessageModel, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("add_ai_chat_request", {
                    chatId,
                    ai,
                    chatInput,
                    chatHistory,
                    streamChannel,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getLocalOllamaModels(
        connectionData: OllamaConnectionData | null,
    ): Promise<Result<LocalModelData[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_local_ollama_models", { connectionData }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getOllamaModelInfo(
        modelName: string,
    ): Promise<Result<LocalModelDetailData, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_ollama_model_info", { modelName }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async ollamaModelExistsLocally(
        modelName: string,
    ): Promise<Result<boolean, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("ollama_model_exists_locally", { modelName }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Sets the language model for a specific chat session.
     */
    async saveChatModel(
        chatModel: AiChatModel,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_chat_model", { chatModel }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createTask(
        task: TaskModel,
        tags: TaskTagModel[],
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_task", { task, tags }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createTaskList(
        taskList: TaskListModel,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_task_list", { taskList }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteTaskById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_task_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteTaskListById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_task_list_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTaskById(
        id: string,
    ): Promise<Result<TaskModelWithTags, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_task_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Accepts the list.id field and a vec of tasks associated with this list. This is required to get
     * around the date parsing issue in Rust.
     */
    async getTaskListData(
        listId: string,
        listTasks: TaskModel[],
    ): Promise<Result<TaskListData, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_task_list_data", { listId, listTasks }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async countTasksInList(id: string): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("count_tasks_in_list", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getAllTaskLists(): Promise<Result<TaskListModel[], FlusterError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_all_task_lists") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTaskListCount(
        predicate: string | null,
    ): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_task_list_count", { predicate }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTaskCount(
        predicate: string | null,
    ): Promise<Result<string, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_task_count", { predicate }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getIncompleteTasksWithDueDate(): Promise<
        Result<TaskModel[], FlusterError>
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_incomplete_tasks_with_due_date"),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getTaskListTasks(
        taskListId: string,
    ): Promise<Result<TaskModel[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_task_list_tasks", { taskListId }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createNewKanbanBoard(
        item: KanbanBoardModel,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_new_kanban_board", { item }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteKanbanBoardById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_kanban_board_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteKanbanBoardCardById(
        id: string,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_kanban_board_card_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createNewKanbanBoardCard(
        item: KanbanCardModel,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_new_kanban_board_card", { item }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getKanbanBoardById(
        id: string,
    ): Promise<Result<KanbanBoardData, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_kanban_board_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getKanbanBoardList(
        predicate: string | null,
        pagination: PaginationProps | null,
    ): Promise<Result<KanbanBoardListData, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_kanban_board_list", {
                    predicate,
                    pagination,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveFlashcard(
        item: FlashcardModel,
        tags: string[],
        topic: string | null,
        subject: string | null,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_flashcard", {
                    item,
                    tags,
                    topic,
                    subject,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getFlashcardData(
        id: string,
    ): Promise<Result<FlashcardGroup, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_flashcard_data", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getFlashcardTopicsAndSubjects(): Promise<
        Result<FlashcardTopicSubjectData, FlusterError>
    > {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_flashcard_topics_and_subjects"),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteFlashcardById(id: string): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("delete_flashcard_by_id", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async getFlashcardSummaries(
        pagination: PaginationProps,
    ): Promise<Result<FlashcardModel[], FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("get_flashcard_summaries", { pagination }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async setFlashcardCompleteStatus(
        flashcardId: string,
        correct: boolean,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("set_flashcard_complete_status", {
                    flashcardId,
                    correct,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async generateNewToken(length: string): Promise<string> {
        return await TAURI_INVOKE("generate_new_token", { length });
    },
    async getPlotlyTheme(themeId: PlotlyTheme): Promise<string> {
        return await TAURI_INVOKE("get_plotly_theme", { themeId });
    },
    async loadWhiteboardInitialData(
        id: string,
    ): Promise<Result<WhiteboardModel | null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("load_whiteboard_initial_data", { id }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveWhiteboardData(
        id: string,
        whiteboardData: string,
        label: string | null,
    ): Promise<Result<null, FlusterError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("save_whiteboard_data", {
                    id,
                    whiteboardData,
                    label,
                }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
};

/** user-defined events **/

export const events = __makeEvents__<{
    setDbConnectionUri: SetDbConnectionUri;
    toastConfig: ToastConfig;
}>({
    setDbConnectionUri: "set-db-connection-uri",
    toastConfig: "toast-config",
});

/** user-defined constants **/

/** user-defined types **/

/**
 * A utility struct that combines the ChatModel, AiChatMessageResponse, and AiChatMessageRequest
 * entities into a single struct.
 */
export type AiChatData = { chat: AiChatModel; messages: AiChatMessageModel[] };
export type AiChatMessageModel = {
    id: string;
    /**
     * The id of the accompanying AiChatModel row.
     */
    chat_id: string;
    /**
     * The user's input as the request body.
     */
    body: string;
    role: AiChatMessageRole;
    /**
     * The stringified unix timestamp of the time the message was sent.
     */
    sent_at: string;
};
export type AiChatMessageRole = "User" | "Assistant" | "System" | "Tool";
export type AiChatMessageUpdateEventProps = {
    /**
     * The id of the entire chat.
     */
    chat_id: string;
    /**
     * The id of the message
     */
    message_id: string;
    /**
     * The body of the message, already concatenated.
     */
    content: string;
};
/**
 * The database entity representing a specific chat historys
 */
export type AiChatModel = {
    id: string;
    label: string;
    model: string;
    temperature: number;
    repeat_penalty: number;
    top_k: number;
    top_p: number;
    ctime: string;
};
export type AiSyncSettings = {
    embedding_model: string;
    language_model: string;
    with_ai: boolean;
    max_text_split_tokens: string;
};
export type AllTaggableData = {
    tags: SharedTaggableModel[];
    topics: SharedTaggableModel[];
    subjects: SharedTaggableModel[];
};
export type AutoSettingModel = {
    id: string;
    glob: string;
    value: string;
    setting_type: AutoSettingType;
};
export type AutoSettingType = "Tag" | "Topic" | "Subject";
export type AxisGeneratorProps = {
    min: number;
    max: number;
    count: string;
    label: string | null;
};
export type BibEntryModel = {
    id: string;
    user_provided_id: string | null;
    /**
     * The json string representing this item's data.
     */
    data: string;
    ctime: string;
    html_citation: string;
    pdf_path: string | null;
};
export type CrossLanguageEvents =
    | "EmbeddingModelDownloadProgress"
    | "LanguageModelDownloadProgress"
    | "AiChatMessageUpdate";
export type DashboardData = {
    topics: SharedTaggableModel[];
    subjects: SharedTaggableModel[];
    tags: SharedTaggableModel[];
    note_count: string;
    bookmarks: MdxNoteModel[];
    incomplete_tasks: TaskModel[];
};
export type DesktopHealthReport = {
    database_tables_exist: boolean;
    /**
     * This boolean describes the overall health of the desktop app. If any inidividual field
     * that warrents re-initializing is false, this field will be false.
     */
    healthy: boolean;
};
export type DictionaryEntryModel = {
    /**
     * Primary Key
     */
    label: string;
    body: string;
    /**
     * The source string for the mdx source that produces this dictionary entry. This is just
     * a file path for local notes.
     */
    mdx_source: string;
    ctime: string;
};
export type DictionaryEntryModelWithoutSource = {
    /**
     * Primary Key
     */
    label: string;
    body: string;
    ctime: string;
};
export type EmbbeddedDocFile = { content: string; path: string };
export type EquationData = {
    equation: EquationModel;
    tags: SharedTaggableModel[];
};
export type EquationModel = {
    /**
     * This is the traditional id field, generated by uuid.
     */
    id: string;
    /**
     * The equation_id field is the 'id' field as provided from the user. This is used to
     * reference equations throughout their notes in a way that makes sense to the user as
     * opposed to an arbitrary string.
     */
    equation_id: string | null;
    /**
     * The title or label for the equation.
     */
    label: string;
    /**
     * The equation latex string.
     */
    body: string;
    desc: string;
    /**
     * Time snippet is initially created.
     */
    ctime: string;
    /**
     * Time snippet is last updated.
     */
    utime: string;
};
export type FlashcardGroup = {
    id: string;
    label: string;
    answer: string;
    answer_description: string;
    question: string;
    question_description: string;
    correct_count: number;
    incorrect_count: number;
    tags: FlashcardTagModel[];
    topic: FlashcardTopicModel | null;
    subject: FlashcardSubjectModel | null;
};
export type FlashcardModel = {
    id: string;
    label: string;
    answer: string;
    answer_description: string;
    question: string;
    question_description: string;
    correct_count: number;
    incorrect_count: number;
};
export type FlashcardSubjectModel = {
    flashcard_id: string;
    subject_value: string;
};
export type FlashcardTagModel = { flashcard_id: string; tag_value: string };
export type FlashcardTopicModel = { flashcard_id: string; topic_value: string };
export type FlashcardTopicSubjectData = {
    subjects: SharedTaggableModel[];
    topics: SharedTaggableModel[];
};
export type FlusterError =
    | "CanaryError"
    | "FailToFindBackupDataVersion"
    | "FailToStreamFromRust"
    | "FailToPerformSemanticSearch"
    | "FailToGenerateVectors"
    | "OperatingSystemNotSupported"
    | "FailToSendEvent"
    | "FailToLoadDocs"
    | { FailToLoadEnvironmentVariable: string }
    | "FailToParseDate"
    | "FailToWriteChatSession"
    | "FileDoesNotExist"
    | "FailToReadFile"
    | "FailToCreateFile"
    | "FailToReadChatSession"
    | "FailToParseJsonString"
    | "FailToSerializeJson"
    | "FailToParseTabularFile"
    | "NoAiProvidersConfigured"
    | "FailToGenerateChatResponse"
    | "FailToLoadModel"
    | "FailToCreateEmbeddingVector"
    | "FailToGetSemanticResults"
    | "FailToCreateQrCode"
    | "FailToCount"
    | "NotImplemented"
    | "FailToCopyFiles"
    | "FailToWriteFile"
    | "FailToSaveSettings"
    | "FailToReadSettings"
    | "DatabaseError"
    | "FailToParseBibFile"
    | "SettingsBibPathNotFound"
    | "CannotParseBibfile"
    | "FailToFindDataDirectory"
    | "FailToCreateIndex"
    | "FailToSerialize"
    | "NotFoundById"
    | "DuplicateId"
    | "FailToDelete"
    | "FailToClean"
    | "FailToCreateTable"
    | "FailToOpenTable"
    | "FailToConnect"
    | "FailToStartDb"
    | "FailToDropTable"
    | "FailToStopDb"
    | "FailToCreateEntity"
    | "FailToCreateSnippet"
    | "FailToFind"
    | "FailToFindById"
    | "FailToCreatePath"
    | "FailToCreateTag"
    | "FailToCreateSubject"
    | { DataDirNotFound: [] }
    | { FailToClearDirectory: string }
    | "FailToCreateTopic"
    | "FailToLocateStorageDir"
    | { FailToReadFileSystemPath: string }
    | "FailToReadMathjaxFont"
    | { FailToSaveFile: string }
    | { MdxParsingError: string }
    | { NoTitleError: string }
    | "FailToGatherMdxGroups"
    | { AttemptedToParseFileWasntFound: string }
    | { FailToSaveMdxNote: string }
    /**
     * Taggables
     *
     */
    | "FailToUpsertTags"
    | "FailToExecutePython"
    | "FailToGetModels";
/**
 * This is the model as it exists in the database. All related external tables can be combined to form a
 * `FrontMatterModel` struct, which more closely represents the front matter as it appears in a
 * user's notes.
 */
export type FrontMatterBaseModel = {
    id: string;
    mdx_note_file_path: string;
    /**
     * The user_provided_id is the id field as it appears in the user's note.  The id field in
     * this struct is generated by Surreal.
     */
    user_provided_id: string | null;
    title: string;
    summary: string | null;
    list_id: string | null;
    list_index: string | null;
    subject: string | null;
    topic: string | null;
};
/**
 * This model mirrors the structure of the front matter as it appears in a user's note, where the
 * nested entities represent the data as it is stored in the database. This model should handle
 * all parsing and saving of all nested models.
 */
export type FrontMatterModel = {
    id: string;
    mdx_note_file_path: string;
    /**
     * The user_provided_id is the id field as it appears in the user's note.  The id field in
     * this struct is generated by Surreal.
     */
    user_provided_id: string | null;
    title: string;
    summary: string | null;
    list_id: string | null;
    list_index: string | null;
    tags: SharedTaggableModel[];
    subject: SharedTaggableModel | null;
    topic: SharedTaggableModel | null;
};
export type GetParsableFilesOptions = {
    /**
     * The path to the user's note's directory
     */
    dir_path: string;
    /**
     * The stringified integer representing the number of threads.
     */
    n_threads: string;
    use_git_ignore: boolean;
};
export type GetSnippetsParams = { langs: string[] | null };
export type InternalEmbeddedDocsId =
    /**
     * This is the super general public version of the model, designed to peak interest, not
     * prove the model.
     */
    | "ModelIntro"
    /**
     * This is the somewhat academic version of the model. Not fully peer-review worthy, but
     * who gives a shit. It's right.
     */
    | "ModelFull"
    /**
     * How to contribute
     */
    | "HowToContribute"
    | "GettingStarted"
    | "ColorProps"
    | "IntroToJsx"
    | "JupyterSetup"
    | "QuickReference"
    | "Mermaid"
    | "OllamaSetup";
export type JsonValue =
    | null
    | boolean
    | number
    | string
    | JsonValue[]
    | Partial<{ [key in string]: JsonValue }>;
export type KanbanBoardData = { board: KanbanBoardModel };
export type KanbanBoardListData = { boards: KanbanBoardModel[] };
export type KanbanBoardModel = {
    id: string;
    label: string;
    desc: string | null;
};
export type KanbanCardModel = {
    id: string;
    label: string;
    desc: string | null;
    body: string | null;
    /**
     * The id field of the KanbanBoardListModel that contains this entry.
     */
    list_id: string;
};
export type LocalModelData = {
    name: string;
    modified_at: string;
    size: string;
};
export type LocalModelDetailData = {
    license: string;
    modelfile: string;
    parameters: string;
    template: string;
};
export type MathjaxData = {
    root: string;
    main_path: string;
    font_path: string;
};
export type MdxBookmarkData = {
    note: MdxNoteModel;
    front_matter: FrontMatterBaseModel;
};
export type MdxNoteGroup = {
    mdx: MdxNoteModel;
    front_matter: FrontMatterModel;
    tags: SharedTaggableModel[];
    equations: EquationModel[];
    dictionary_entries: DictionaryEntryModel[];
    citations: BibEntryModel[];
    note_links: MdxNoteLinkModel[];
};
export type MdxNoteLinkModel = {
    mdx_note_file_path_from: string;
    mdx_user_provided_id_to: string;
};
export type MdxNoteModel = {
    /**
     * create a new model. This file_path becomes essentially the primary key.
     */
    file_path: string;
    raw_body: string;
    ctime: string;
    /**
     * This field is updated each time a note is accessed in milliseconds.
     */
    last_read: string;
};
export type NoteSummary = { title: string; file_path: string };
export type OllamaConnectionData = { url: string; port: number };
export type PaginationProps = { per_page: string; page_number: string };
export type ParsableFiles = { mdx_files: string[]; csv_files: string[] };
export type PlotlyTheme =
    | "ggplot2"
    | "seaborn"
    | "simple_white"
    | "plotly"
    | "plotly_white"
    | "plotly_dark"
    | "presentation"
    | "xgridoff"
    | "ygridoff"
    | "gridon"
    | "none";
export type RecentlyAccessedNoteData = { last_read: string; file_path: string };
export type SearchOrder = "Created";
export type SearchParams = {
    order: SearchOrder | null;
    per_page: number | null;
    page: number | null;
};
export type SemanticSearchResults = { notes: MdxNoteGroup[] };
export type SetDbConnectionUri = { uri: string };
export type SharedTaggableModel = { value: string; utime: string };
export type SnippetData = { snippet: SnippetModel; tags: SnippetTagModel[] };
/**
 * The SnippetModel is the snippet representation that is passed back and forth across language
 * boundries to get around serialization issues with the SnippetEntity methods.
 */
export type SnippetModel = {
    id: string;
    /**
     * A title or label for the snippet.
     */
    label: string;
    /**
     * The code the snippet contains.
     */
    body: string;
    /**
     * An optional short description.
     */
    desc: string | null;
    /**
     * THe language of the snippet.
     */
    lang: string;
    /**
     * The time the snippet was created.
     */
    ctime: string;
    /**
     * The time the snippet was last updated.
     */
    utime: string;
};
export type SnippetTagModel = { snippet_id: string; tag_value: string };
export type SupportedOperatingSystem =
    | "Windows"
    | "Mac"
    | "Linux"
    | "Ios"
    | "Android"
    | "NotSupported";
export type SyncFilesystemDirectoryOptions = {
    /**
     * The path to the user's note's directory
     */
    dir_path: string;
    bib_path: string | null;
    /**
     * The stringified integer representing the number of threads.
     */
    n_threads: string;
    use_git_ignore: boolean;
    /**
     * defaults to true
     */
    existing_taggables: AllTaggableData;
    /**
     * Embeddings model to be used when syncing.
     */
    ai: AiSyncSettings;
    recently_accessed_notes: RecentlyAccessedNoteData[];
    ollama_url: string;
    ollama_port: number;
    min_chunk_length: string;
    max_chunk_length: string;
};
export type TaskListData = { list: TaskListModel; items: TaskModelWithTags[] };
export type TaskListModel = {
    id: string;
    label: string;
    desc: string | null;
    ctime: string;
};
export type TaskModel = {
    id: string;
    /**
     * The id of the parent task list.
     */
    task_list_id: string;
    label: string;
    /**
     * notes can be any mdx string.
     */
    notes: string;
    /**
     * The optional due date for the task.
     */
    due_at: string | null;
    /**
     * Time the task was created.
     */
    ctime: string;
    complete: boolean;
};
export type TaskModelWithTags = {
    id: string;
    /**
     * The id of the parent task list.
     */
    task_list_id: string;
    label: string;
    /**
     * notes can be any mdx string.
     */
    notes: string;
    /**
     * The optional due date for the task.
     */
    due_at: string | null;
    /**
     * Time the task was created.
     */
    ctime: string;
    complete: boolean;
    tags: SharedTaggableModel[];
};
export type TaskTagModel = { task_id: string; tag_value: string };
export type ToastConfig = {
    title: string;
    body: string;
    duration: number;
    variant: ToastVariant;
    /**
     * id is required to allow items to be removed reliably. It just needs to be unique.
     */
    id: string;
};
export type ToastVariant = "Success" | "Info" | "Error";
export type TocEntry = { depth: number; body: string };
/**
 * The search results returned froma  taggable input or via a traditional text based query.
 */
export type TraditionalSearchResults = {
    notes: MdxNoteGroup[];
    tasks: TaskModel[];
    equations: EquationData[];
    snippets: SnippetData[];
    flashcards: FlashcardModel[];
};
export type ValidTabularFileExtensions = "Csv";
export type WhiteboardModel = {
    /**
     * A user provided id given to the Whiteboard component.
     */
    id: string;
    /**
     * The stingified json state of the whiteboard..
     */
    state: string;
    /**
     * A string used to specify the whiteboard in search results and such.
     */
    label: string;
    /**
     * Time the whiteboard was created.
     */
    ctime: string;
    /**
     * Time the whiteboard was last updated..
     */
    utime: string;
};

/** tauri-specta globals **/

import {
    invoke as TAURI_INVOKE,
    Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (
        cb: TAURI_API_EVENT.EventCallback<T>,
    ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (
        cb: TAURI_API_EVENT.EventCallback<T>,
    ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
    | { status: "ok"; data: T }
    | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
    mappings: Record<keyof T, string>,
) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
                (handle: __WebviewWindow__): __EventObj__<T[K]>;
            };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((() => { }) as any, {
                    apply: (_, __, [window]: [__WebviewWindow__]) => ({
                        listen: (arg: any) => window.listen(name, arg),
                        once: (arg: any) => window.once(name, arg),
                        emit: (arg: any) => window.emit(name, arg),
                    }),
                    get: (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    },
                });
            },
        },
    );
}
